<!DOCTYPE Robei>
<Module Height="647" Name="uart_16550" Parameters="" Include="uart_def.v,sfifo_def.v" File="Current/uart_16550.model" Comment="" Color="#d3d3d3" X="0" Width="1040" Class="module" Y="0" Type="module" Code="// Uart tx_en signal generate&#xa;reg tx_request;&#xa;&#xa;always @( posedge generate_clk1_clk_out or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    tx_request &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else begin&#xa;    case( { tx_buf_full, sfifo_tx_empty } ) &#xa;      2'b00: begin&#xa;        tx_request &lt;= #`DEL 1'b1;&#xa;      end&#xa;      2'b01: begin&#xa;        tx_request &lt;= #`DEL 1'b0;&#xa;      end&#xa;      2'b10: begin&#xa;        tx_request &lt;= #`DEL 1'b0;&#xa;      end&#xa;      2'b11: begin&#xa;        tx_request &lt;= #`DEL 1'b0;&#xa;      end&#xa;    endcase&#xa;  end&#xa;end      &#xa;&#xa;// Sfifo_rx write_n signal generate&#xa;reg     rx_done_q;&#xa;reg     rx_done_n;&#xa;wire    rx_done_flag;&#xa;&#xa;always @( posedge generate_clk1_clk_out or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    rx_done_q &lt;= #`DEL 1'b0;&#xa;    rx_done_n &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else begin&#xa;    rx_done_n &lt;= #`DEL rx_done;&#xa;    rx_done_q &lt;= #`DEL rx_done_n;&#xa;  end&#xa;end&#xa;assign rx_done_flag = ~rx_done_q &amp;&amp; ( rx_done_n );&#xa;assign write_en = ~rx_done_flag;&#xa;&#xa;// Sfifo_tx read_n signal generate&#xa;wire [3:0] counter_of_tx;&#xa;assign read_request = ( counter_of_tx == 0 ) ? 1 : 0;&#xa;" Parent="0">
 <Module Height="144" Name="generate_clk1" Parameters="" Include="uart_def.v" File="Current/generate_clk.model" Comment="" Color="#d3d3d3" X="167.112" Width="134" Class="generate_clk" Y="43.9918" Type="model" Code="parameter CLOCK = 12000000;  // This parameter is equal to the external crystal oscillator on FPGA &#xa;&#xa;wire [`DIV_LENGTH-1:0] division;&#xa;assign division = CLOCK / ( 16 * baud_rate );&#xa;&#xa;//&#xa;// Even division, which duty is 50%&#xa;//&#xa;reg                       clk_even;&#xa;reg     [`DIV_LENGTH-1:0] cnt_even;&#xa;wire    [`DIV_LENGTH-1:0] division_even;&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    cnt_even &lt;= #`DEL `DIV_LENGTH'd0;&#xa;    clk_even &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else if( division[0]==1 ) begin&#xa;    cnt_even &lt;= #`DEL `DIV_LENGTH'd0;&#xa;    clk_even &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else begin&#xa;    if( cnt_even == ( division_even - 1 ) ) begin&#xa;      cnt_even &lt;= #`DEL `DIV_LENGTH'd0;&#xa;      clk_even &lt;= #`DEL ~clk_even;&#xa;    end&#xa;    else begin&#xa;      cnt_even &lt;= #`DEL cnt_even + 1'd1;&#xa;      clk_even &lt;= #`DEL clk_even;&#xa;    end&#xa;  end&#xa;end     &#xa;&#xa;assign division_even = ( division[0] == 0 ) ? ( division >> 1 ) : 0;&#xa;&#xa;//&#xa;// Odd division, which duty is 50%&#xa;//&#xa;reg                     clk_p;&#xa;reg                     clk_n;&#xa;wire                    clk_odd;&#xa;reg   [`DIV_LENGTH-1:0] cnt_p;&#xa;reg   [`DIV_LENGTH-1:0] cnt_n;&#xa;wire  [`DIV_LENGTH-1:0] division_odd;&#xa;&#xa;//&#xa;// Rising edge&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    clk_p &lt;= #`DEL 1'b0;&#xa;    cnt_p &lt;= #`DEL `DIV_LENGTH'b0;&#xa;  end&#xa;  else if( division[0]==0 ) begin    &#xa;    clk_p &lt;= #`DEL 1'b0;&#xa;    cnt_p &lt;= #`DEL `DIV_LENGTH'b0;&#xa;  end&#xa;  else begin&#xa;    if( cnt_p == division_odd - 1 ) begin&#xa;      clk_p &lt;= #`DEL ~clk_p;&#xa;      cnt_p &lt;= #`DEL `DIV_LENGTH'b0;&#xa;    end&#xa;    else if( cnt_p == ( ( division - 1 ) >> 1 ) )begin&#xa;      clk_p &lt;= #`DEL ~clk_p;&#xa;      cnt_p &lt;= #`DEL cnt_p + 1'b1;&#xa;    end&#xa;    else begin&#xa;      clk_p &lt;= #`DEL clk_p;&#xa;      cnt_p &lt;= #`DEL cnt_p + 1'b1;&#xa;    end&#xa;  end&#xa;end      &#xa;&#xa;//&#xa;// Falling edge&#xa;always @( negedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    clk_n &lt;= #`DEL 1'b0;&#xa;    cnt_n &lt;= #`DEL `DIV_LENGTH'b0;&#xa;  end&#xa;  else if( division[0] == 0 ) begin    &#xa;    clk_n &lt;= #`DEL 1'b0;&#xa;    cnt_n &lt;= #`DEL `DIV_LENGTH'b0;&#xa;  end&#xa;  else begin&#xa;    if( cnt_n == division_odd - 1 ) begin&#xa;      clk_n &lt;= #`DEL ~clk_n;&#xa;      cnt_n &lt;= #`DEL `DIV_LENGTH'b0;&#xa;    end&#xa;    else if( cnt_n == ( ( division - 1 ) >> 1 ) )begin&#xa;      clk_n &lt;= #`DEL ~clk_n;&#xa;      cnt_n &lt;= #`DEL cnt_n + `DIV_LENGTH'b1;&#xa;    end&#xa;    else begin&#xa;      clk_n &lt;= #`DEL clk_n;&#xa;      cnt_n &lt;= #`DEL cnt_n + `DIV_LENGTH'b1;&#xa;    end&#xa;  end&#xa;end     &#xa;&#xa;&#xa;assign division_odd = ( division[0] == 1 ) ? division : 0;&#xa;assign clk_odd = clk_n | clk_p;&#xa;&#xa;assign clk_out = ( division[0] == 1 ) ? clk_odd : clk_even;" Parent="uart_16550">
  <Port Height="20" Name="clk" Connect="" Side="left" Color="#0000ff" X="-0.149254" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.125" Inout="input" Parent="generate_clk1"/>
  <Port Height="20" Name="rst_n" Connect="" Side="left" Color="#00ffff" X="-0.149254" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.3125" Inout="input" Parent="generate_clk1"/>
  <Port Height="20" Name="baud_rate" Connect="" Side="left" Color="#5f9ea0" X="-0.149254" Width="20" Function="" Datatype="wire" Datasize="19" Y="0.513889" Inout="input" Parent="generate_clk1"/>
  <Port Height="20" Name="clk_out" Connect="" Side="right" Color="#d2691e" X="0.850746" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.263889" Inout="output" Parent="generate_clk1"/>
 </Module>
 <Module Height="337" Name="uart1" Parameters="" Include="uart_def.v" File="Current/uart.model" Comment="" Color="#d3d3d3" X="595.462" Width="135" Class="uart" Y="66.676" Type="model" Code="//&#xa;// Parity is equal to 0 means that there should not have parity bit. Otherwise, there should be one parity bit.&#xa;//&#xa;wire       parity_bit;&#xa;assign parity_bit = ( ~|parity ) ? 0 : 1; &#xa;&#xa;//&#xa;// This block is used to receive data&#xa;//&#xa;&#xa;//&#xa;// Edge deteted&#xa;//&#xa;&#xa;reg                     rx_q;&#xa;wire                    rx_start;&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    rx_q &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else begin&#xa;    rx_q &lt;= #`DEL rx;&#xa;  end&#xa;end      &#xa;// Falling edge effective&#xa;assign rx_start = ( rx_q &amp;&amp; ~rx );&#xa;&#xa;//&#xa;// Counter of rx&#xa;//&#xa;&#xa;reg  [7:0]  rx_cnt;&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if ( ~rst_n ) begin&#xa;    rx_cnt &lt;= #`DEL 8'd0;&#xa;  end&#xa;  else if ( ns_rx == IDLE_RX || ns_rx == ERROR_RX ) begin&#xa;    rx_cnt &lt;= #`DEL 8'd0;&#xa;  end  // If the next status is IDLE or ERROR, then don't count&#xa;  else begin&#xa;    rx_cnt &lt;= #`DEL rx_cnt + 1'd1;&#xa;  end  // If the next status is not IDLE or ERROR, then begin to count&#xa;end&#xa;&#xa;//&#xa;// Three paragraph FSM of receive &#xa;//&#xa;reg       [3:0]   cs_rx;&#xa;reg       [3:0]   ns_rx;&#xa;parameter [3:0]   IDLE_RX   = 4'b0000,&#xa;  START_RX     = 4'b0001,&#xa;  RECEIVE_RX   = 4'b0010,&#xa;  STOP_RX      = 4'b0100,&#xa;  ERROR_RX     = 4'b1000;&#xa;&#xa;// FSM one&#xa;//&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if ( !rst_n ) begin&#xa;    cs_rx &lt;= IDLE_RX;&#xa;  end&#xa;  else begin&#xa;    cs_rx &lt;= ns_rx;&#xa;  end&#xa;end&#xa;&#xa;// FSM two&#xa;//&#xa;&#xa;// cnt_parity_rx means that rx_cnt has counted to the parity bit&#xa;wire [7:0] cnt_parity_rx;&#xa;assign cnt_parity_rx = ( 24 + ( data_bit + parity_bit ) * 16 ); &#xa;&#xa;always @( * ) begin&#xa;  ns_rx = IDLE_RX;&#xa;  case ( cs_rx )&#xa;    IDLE_RX: begin&#xa;      if( rx_start ) begin&#xa;        ns_rx = START_RX;  // If there has a falling edge in rx, then transmit to START&#xa;      end&#xa;      else begin&#xa;        ns_rx = IDLE_RX;&#xa;      end&#xa;    end&#xa;    START_RX: begin &#xa;      if ( rx &amp;&amp; rx_cnt &lt; 8 ) begin&#xa;        ns_rx = ERROR_RX;  // If rx has a high volage in START status, there must be an error&#xa;      end &#xa;      else if( rx_cnt == 8 ) begin &#xa;        ns_rx = RECEIVE_RX;  // If rx can remain low volage for 8 cycles, we believe communication is correct, then begin to receive data&#xa;      end&#xa;      else begin &#xa;        ns_rx = START_RX; &#xa;      end&#xa;    end&#xa;    RECEIVE_RX: begin&#xa;      if ( rx_cnt == cnt_parity_rx ) begin&#xa;        ns_rx = STOP_RX;&#xa;      end &#xa;      else begin &#xa;        ns_rx = RECEIVE_RX;&#xa;      end&#xa;    end &#xa;    STOP_RX: begin&#xa;      if( rx_cnt == cnt_parity_rx + ( stop_bit * 16 ) ) begin&#xa;        ns_rx = IDLE_RX;&#xa;      end&#xa;      else begin&#xa;        ns_rx = STOP_RX;&#xa;      end&#xa;    end&#xa;    ERROR_RX: begin &#xa;      ns_rx = IDLE_RX; &#xa;    end &#xa;  endcase&#xa;end&#xa;&#xa;// FSM three&#xa;//&#xa;&#xa;reg [3:0] count_cycle_rx; // Used to count the bit num of received data&#xa;reg [8:0] data_received_temp;&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin &#xa;  if ( !rst_n ) begin &#xa;    data_received_temp &lt;= #`DEL 9'd0;&#xa;    rx_buf_full        &lt;= #`DEL 1'b0;&#xa;    count_cycle_rx     &lt;= #`DEL 4'd1;&#xa;  end&#xa;  else begin &#xa;    case ( ns_rx )&#xa;      IDLE_RX: begin&#xa;        data_received_temp &lt;= #`DEL 9'd0;&#xa;        rx_buf_full        &lt;= #`DEL 1'b0;&#xa;        count_cycle_rx     &lt;= #`DEL 4'd1;&#xa;      end&#xa;      START_RX: begin&#xa;        data_received_temp &lt;= #`DEL 9'd0;&#xa;        rx_buf_full        &lt;= #`DEL 1'b0;&#xa;        count_cycle_rx     &lt;= #`DEL 4'd1;&#xa;      end&#xa;      RECEIVE_RX: begin&#xa;        if( count_cycle_rx == ( data_bit + parity_bit ) &amp;&amp; ( rx_cnt == 24 + 16 * ( count_cycle_rx ) ) ) begin&#xa;          data_received_temp[count_cycle_rx - 1] &lt;= #`DEL rx;  // Parity check bit&#xa;          rx_buf_full                            &lt;= #`DEL 1'b0;&#xa;          count_cycle_rx                         &lt;= #`DEL 4'd1; // Reset count_cycle_rx &#xa;        end  // Receive parity check bit&#xa;        else if( rx_cnt == ( 24 + ( count_cycle_rx - 1 ) * 16 ) ) begin&#xa;          data_received_temp[count_cycle_rx - 1] &lt;= #`DEL rx;&#xa;          rx_buf_full                            &lt;= #`DEL 1'b0;&#xa;          count_cycle_rx                         &lt;= #`DEL count_cycle_rx + 1'b1;&#xa;        end  // Data bit&#xa;      end&#xa;      STOP_RX: begin&#xa;        if( rx_cnt == cnt_parity_rx + ( stop_bit * 16 ) - 8 ) begin  // -8 is to catch the stop bit&#xa;          data_received_temp &lt;= #`DEL data_received_temp;&#xa;          rx_buf_full        &lt;= #`DEL 1'b1;&#xa;          count_cycle_rx     &lt;= #`DEL count_cycle_rx;&#xa;        end&#xa;      end&#xa;      ERROR_RX: begin        &#xa;        data_received_temp &lt;= #`DEL 9'd0;&#xa;        rx_buf_full        &lt;= #`DEL 1'b0;&#xa;        count_cycle_rx     &lt;= #`DEL 4'd1; &#xa;      end&#xa;    endcase &#xa;  end &#xa;end      &#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    data_received &lt;= #`DEL 9'b0;&#xa;  end&#xa;  else if( rx_buf_full ) begin&#xa;    data_received &lt;= #`DEL data_received_temp;  // Ensure data can be collected&#xa;  end&#xa;end           &#xa;&#xa;&#xa;&#xa;//&#xa;// This block is used to send data&#xa;//&#xa;&#xa;// &#xa;// Edge deteted&#xa;//&#xa;&#xa;reg         tx_en_q;&#xa;wire        tx_start;&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    tx_en_q &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else begin&#xa;    tx_en_q &lt;= #`DEL tx_en;&#xa;  end&#xa;end      &#xa;// Rising edge effective&#xa;assign tx_start = ( ~tx_en_q &amp;&amp; tx_en );&#xa;&#xa;//&#xa;// Transmit data_send to shift_reg&#xa;//&#xa;&#xa;reg  [8:0]  shift_reg;&#xa;&#xa;always @( posedge tx_start or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    shift_reg &lt;= #`DEL 9'd0;&#xa;  end&#xa;  else begin&#xa;    shift_reg[7:0] &lt;= #`DEL data_send;&#xa;    //&#xa;    // Parity check bit&#xa;    case( parity )&#xa;      3'b000: shift_reg[8]   &lt;= #`DEL 0;   // No parity check&#xa;      3'b001: shift_reg[8]   &lt;= #`DEL ( ^data_send ) ? 0 : 1;  // Odd check&#xa;      3'b010: shift_reg[8]   &lt;= #`DEL ( ^data_send ) ? 1 : 0;  // Even check&#xa;      3'b011: shift_reg[8]   &lt;= #`DEL 0;  // 0 check&#xa;      3'b100: shift_reg[8]   &lt;= #`DEL 1;  // 1 check&#xa;    endcase&#xa;  end&#xa;end      &#xa;&#xa;//&#xa;// Frequence division&#xa;//&#xa;&#xa;reg  [7:0]  tx_cnt;&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if ( ~rst_n ) begin&#xa;    tx_cnt &lt;= #`DEL 8'd0;&#xa;  end&#xa;  else if ( ns_tx == IDLE_TX ) begin&#xa;    tx_cnt &lt;= #`DEL 8'd0;&#xa;  end&#xa;  else begin&#xa;    tx_cnt &lt;= #`DEL tx_cnt + 1'b1;&#xa;  end&#xa;end&#xa;&#xa;//&#xa;// Three paragraph FSM of send data&#xa;//&#xa;reg       [2:0]   cs_tx;&#xa;reg       [2:0]   ns_tx;&#xa;parameter [2:0]  IDLE_TX   = 3'b000,&#xa;  START_TX     = 3'b001,&#xa;  SEND_TX      = 3'b010,&#xa;  STOP_TX      = 3'b100;&#xa;&#xa;//&#xa;// FSM one&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if ( !rst_n ) begin&#xa;    cs_tx &lt;= IDLE_TX;&#xa;  end&#xa;  else begin&#xa;    cs_tx &lt;= ns_tx;&#xa;  end&#xa;end&#xa;&#xa;// &#xa;// FSM two&#xa;&#xa;// cnt_parity_tx means that tx_cnt has counted to the parity bit&#xa;wire [7:0] cnt_parity_tx;&#xa;assign cnt_parity_tx = ( data_bit + parity_bit + 1 ) * 16; &#xa;&#xa;always @( * ) begin&#xa;  ns_tx = IDLE_TX;&#xa;  case ( cs_tx )&#xa;    IDLE_TX: begin&#xa;      if ( tx_start ) begin&#xa;        ns_tx = START_TX;&#xa;      end&#xa;      else begin&#xa;        ns_tx = IDLE_TX;&#xa;      end&#xa;    end&#xa;    START_TX: begin&#xa;      ns_tx = SEND_TX;&#xa;    end &#xa;    SEND_TX: begin &#xa;      if ( tx_cnt == cnt_parity_tx ) begin&#xa;        ns_tx = STOP_TX; &#xa;      end &#xa;      else begin &#xa;        ns_tx = SEND_TX;&#xa;      end&#xa;    end&#xa;    STOP_TX: begin &#xa;      if ( tx_cnt == cnt_parity_tx + stop_bit * 16 ) begin&#xa;        ns_tx = IDLE_TX; &#xa;      end&#xa;      else begin&#xa;        ns_tx = STOP_TX;&#xa;      end&#xa;    end &#xa;  endcase &#xa;end&#xa;&#xa; &#xa;// FSM three &#xa;//&#xa;&#xa;reg [3:0] count_cycle_tx; // Used to count the bit num of send data&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin &#xa;  if ( !rst_n ) begin &#xa;    tx          &lt;= #`DEL 1'b1;&#xa;    tx_buf_full &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else begin &#xa;    case ( ns_tx )&#xa;      IDLE_TX: begin&#xa;        tx             &lt;= #`DEL 1'b1;&#xa;        tx_buf_full    &lt;= #`DEL 1'b0;&#xa;        count_cycle_tx &lt;= #`DEL 4'd1;&#xa;      end&#xa;      START_TX: begin&#xa;        tx             &lt;= #`DEL 1'b0;&#xa;        tx_buf_full    &lt;= #`DEL 1'b0;&#xa;        count_cycle_tx &lt;= #`DEL 4'd1;&#xa;      end&#xa;      SEND_TX: begin&#xa;        if( ( count_cycle_tx == parity_bit + data_bit + 1 ) &amp;&amp; ( tx_cnt == 16 * count_cycle_tx ) ) begin&#xa;          tx             &lt;= #`DEL shift_reg[count_cycle_tx-1];&#xa;          tx_buf_full    &lt;= #`DEL 1'b1;&#xa;          count_cycle_tx &lt;= #`DEL 4'd1;&#xa;        end&#xa;        else if( tx_cnt == 16 * count_cycle_tx ) begin&#xa;          tx             &lt;= #`DEL shift_reg[count_cycle_tx-1];&#xa;          tx_buf_full    &lt;= #`DEL 1'b1;&#xa;          count_cycle_tx &lt;= #`DEL count_cycle_tx + 1'b1;&#xa;        end&#xa;      end&#xa;      STOP_TX: begin&#xa;        tx             &lt;= #`DEL 1'b1;&#xa;        tx_buf_full    &lt;= #`DEL 1'b0;&#xa;        count_cycle_tx &lt;= #`DEL 4'd1;&#xa;      end&#xa;    endcase &#xa;  end &#xa;end      &#xa;" Parent="uart_16550">
  <Port Height="20" Name="clk" Connect="" Side="left" Color="#0000ff" X="-0.148148" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.163205" Inout="input" Parent="uart1"/>
  <Port Height="20" Name="rst_n" Connect="" Side="left" Color="#00ffff" X="-0.148148" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.264095" Inout="input" Parent="uart1"/>
  <Port Height="20" Name="rx" Connect="" Side="left" Color="#a52a2a" X="-0.148148" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.0682493" Inout="input" Parent="uart1"/>
  <Port Height="20" Name="tx_en" Connect="tx_request" Side="left" Color="#d2691e" X="-0.148148" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.362018" Inout="input" Parent="uart1"/>
  <Port Height="20" Name="data_send" Connect="" Side="left" Color="#7fff00" X="-0.148148" Width="20" Function="" Datatype="wire" Datasize="8" Y="0.459941" Inout="input" Parent="uart1"/>
  <Port Height="20" Name="parity" Connect="" Side="left" Color="#dc143c" X="-0.148148" Width="20" Function="" Datatype="wire" Datasize="3" Y="0.557864" Inout="input" Parent="uart1"/>
  <Port Height="20" Name="stop_bit" Connect="" Side="left" Color="#b8860b" X="-0.148148" Width="20" Function="Which can be 1 or 2" Datatype="wire" Datasize="2" Y="0.652819" Inout="input" Parent="uart1"/>
  <Port Height="20" Name="data_bit" Connect="" Side="left" Color="#ff8c00" X="-0.148148" Width="20" Function=" It means the length of data, which can be 5, 6, 7 and 8" Datatype="wire" Datasize="4" Y="0.750742" Inout="input" Parent="uart1"/>
  <Port Height="20" Name="tx_buf_full" Connect="" Side="right" Color="#0000ff" X="0.851852" Width="20" Function="" Datatype="reg" Datasize="1" Y="0.136499" Inout="output" Parent="uart1"/>
  <Port Height="20" Name="tx" Connect="" Side="right" Color="#8a2be2" X="0.851852" Width="20" Function="" Datatype="reg" Datasize="1" Y="0.302671" Inout="output" Parent="uart1"/>
  <Port Height="20" Name="data_received" Connect="" Side="right" Color="#a52a2a" X="0.851852" Width="20" Function="" Datatype="reg" Datasize="8" Y="0.468843" Inout="output" Parent="uart1"/>
  <Port Height="20" Name="rx_buf_full" Connect="rx_done" Side="right" Color="#5f9ea0" X="0.851852" Width="20" Function="" Datatype="reg" Datasize="1" Y="0.635015" Inout="output" Parent="uart1"/>
 </Module>
 <Module Height="282" Name="sfifo_rx" Parameters="" Include="sfifo_def.v" File="Current/sfifo.model" Comment="" Color="#d3d3d3" X="777.559" Width="139" Class="sfifo" Y="300.62" Type="model" Code="  // The FIFOmemory. &#xa;  reg   [`FIFO_WIDTH-1:0] fifo_mem[0:`FIFO_DEPTH-1];  // How many locations in the FIFO are occupied?&#xa;  reg   [`FIFO_BITS-1:0]  rd_pointer;  // FIFO write pointer points to the location in the FIFO to write to next&#xa;  reg   [`FIFO_BITS-1:0]  wr_pointer;  &#xa;&#xa;  // ASSIGN STATEMENTS&#xa;  assign #`DEL full  = ( counter == `FIFO_DEPTH ) ? 1'b1 : 1'b0;  // FIFO_DEPTH=16&#xa;  assign #`DEL empty = ( counter == 0 ) ? 1'b1 : 1'b0;&#xa;  assign #`DEL half  = ( counter >= `FIFO_HALF )? 1'b1 : 1'b0;    // FIFO_HALF=8&#xa;&#xa;  //&#xa;  // This block contains counter affected by the clock and reset inputs&#xa;  //&#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      // Reset the FIFO pointer&#xa;      counter    &lt;= #`DEL 'b0;&#xa;    end &#xa;    else if ( ~read_n &amp;&amp; write_n ) begin&#xa;      // Check for FIFO underflow&#xa;      // Decrement the FIFO counter&#xa;      counter &lt;= #`DEL counter - 1;&#xa;    end&#x9;&#xa;    else if ( ~write_n &amp;&amp; read_n ) begin&#xa;      // Increment teh FIFO counter&#xa;      counter &lt;= #`DEL counter + 1;&#xa;    end&#xa;    else begin&#xa;      counter &lt;= counter;&#xa;    end&#xa;  end&#xa;        &#xa;  // Increment the read pointer&#xa;  // Check if the read pointer has gone beyond the depth of&#xa;  // FIFO, so, set it back to the begining of the FIFO&#x9;&#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      // Reset the FIFO pointer&#xa;      rd_pointer &lt;= #`DEL `FIFO_BITS'b0;&#xa;    end &#xa;    else if ( ~read_n ) begin&#xa;      if ( rd_pointer == `FIFO_DEPTH ) begin&#xa;        rd_pointer &lt;= #`DEL `FIFO_BITS'b0; &#xa;      end &#xa;      else begin&#xa;        rd_pointer &lt;= #`DEL rd_pointer + 1;&#xa;      end &#xa;    end &#xa;    else begin&#xa;      rd_pointer &lt;= rd_pointer;&#xa;    end &#xa;  end&#xa;&#xa;  // Increment the write pointer&#xa;  // Check if the write pointer has gone beyond the depth of&#xa;  // FIFO, so, set it back to the begining of the FIFO&#x9;&#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      // Reset the FIFO pointer&#xa;      wr_pointer &lt;= #`DEL `FIFO_BITS'b0;&#xa;    end &#xa;    else if ( ~write_n ) begin&#xa;      if ( wr_pointer == `FIFO_DEPTH ) begin&#xa;        wr_pointer &lt;= #`DEL `FIFO_BITS'b0; &#xa;      end &#xa;      else begin &#xa;        wr_pointer &lt;= #`DEL wr_pointer + 1;&#xa;      end&#xa;    end&#xa;  end &#xa;&#xa;  // This block contains sfifo read data output &#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      data_out &lt;= #`DEL `FIFO_WIDTH'b0;&#xa;    end&#xa;    else if ( ~read_n )begin&#xa;      // Output the data&#xa;      data_out &lt;= #`DEL fifo_mem [ rd_pointer ];&#xa;    end&#xa;  end&#xa;&#xa;  // sfifo write operation&#xa;  always @( posedge clock ) begin&#xa;    if ( ~write_n )begin&#xa;      // Store the data&#xa;      fifo_mem [ wr_pointer ] &lt;= #`DEL data_in; &#xa;    end&#xa;  end&#xa;&#xa;  // This block contains all devices affected by the clock but not reset&#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      data_out &lt;= #`DEL `FIFO_WIDTH'b0;&#xa;    end&#xa;    else if ( ~read_n )begin&#xa;      // Output the data&#xa;      data_out &lt;= #`DEL fifo_mem [ rd_pointer ];&#xa;    end&#xa;    if ( ~write_n )begin&#xa;      // Store the data&#xa;      fifo_mem [ wr_pointer ] &lt;= #`DEL data_in; &#xa;    end&#xa;  end&#xa;&#xa;&#xa;" Parent="uart_16550">
  <Port Height="20" Name="clock" Connect="" Side="left" Color="#0000ff" X="-0.143885" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.0886525" Inout="input" Parent="sfifo_rx"/>
  <Port Height="20" Name="reset_n" Connect="" Side="left" Color="#00ffff" X="-0.143885" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.212766" Inout="input" Parent="sfifo_rx"/>
  <Port Height="20" Name="data_in" Connect="" Side="left" Color="#7fffd4" X="-0.143885" Width="20" Function="" Datatype="wire" Datasize="8" Y="0.578014" Inout="input" Parent="sfifo_rx"/>
  <Port Height="20" Name="read_n" Connect="" Side="left" Color="#006400" X="-0.143885" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.460993" Inout="input" Parent="sfifo_rx"/>
  <Port Height="20" Name="write_n" Connect="write_en" Side="left" Color="#cd5c5c" X="-0.143885" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.70922" Inout="input" Parent="sfifo_rx"/>
  <Port Height="20" Name="data_out" Connect="" Side="right" Color="#ffe4c4" X="0.856115" Width="20" Function="" Datatype="reg" Datasize="8" Y="0.631206" Inout="output" Parent="sfifo_rx"/>
  <Port Height="20" Name="full" Connect="" Side="right" Color="#b8860b" X="0.856115" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.460993" Inout="output" Parent="sfifo_rx"/>
  <Port Height="20" Name="empty" Connect="" Side="right" Color="#bdb76b" X="0.856115" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.131206" Inout="output" Parent="sfifo_rx"/>
  <Port Height="20" Name="half" Connect="" Side="right" Color="#0000ff" X="0.856115" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.29078" Inout="output" Parent="sfifo_rx"/>
  <Port Height="20" Name="counter" Connect="" Side="left" Color="#8a2be2" X="-0.143885" Width="20" Function="" Datatype="reg" Datasize="4" Y="0.329787" Inout="output" Parent="sfifo_rx"/>
 </Module>
 <Module Height="213" Name="sfifo_tx" Parameters="" Include="sfifo_def.v" File="Current/sfifo.model" Comment="" Color="#d3d3d3" X="314.579" Width="120" Class="sfifo" Y="354.275" Type="model" Code="  // The FIFOmemory. &#xa;  reg   [`FIFO_WIDTH-1:0] fifo_mem[0:`FIFO_DEPTH-1];  // How many locations in the FIFO are occupied?&#xa;  reg   [`FIFO_BITS-1:0]  rd_pointer;  // FIFO write pointer points to the location in the FIFO to write to next&#xa;  reg   [`FIFO_BITS-1:0]  wr_pointer;  &#xa;&#xa;  // ASSIGN STATEMENTS&#xa;  assign #`DEL full  = ( counter == `FIFO_DEPTH ) ? 1'b1 : 1'b0;  // FIFO_DEPTH=16&#xa;  assign #`DEL empty = ( counter == 0 ) ? 1'b1 : 1'b0;&#xa;  assign #`DEL half  = ( counter >= `FIFO_HALF )? 1'b1 : 1'b0;    // FIFO_HALF=8&#xa;&#xa;  //&#xa;  // This block contains counter affected by the clock and reset inputs&#xa;  //&#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      // Reset the FIFO pointer&#xa;      counter    &lt;= #`DEL 'b0;&#xa;    end &#xa;    else if ( ~read_n &amp;&amp; write_n ) begin&#xa;      // Check for FIFO underflow&#xa;      // Decrement the FIFO counter&#xa;      counter &lt;= #`DEL counter - 1;&#xa;    end&#x9;&#xa;    else if ( ~write_n &amp;&amp; read_n ) begin&#xa;      // Increment teh FIFO counter&#xa;      counter &lt;= #`DEL counter + 1;&#xa;    end&#xa;    else begin&#xa;      counter &lt;= counter;&#xa;    end&#xa;  end&#xa;        &#xa;  // Increment the read pointer&#xa;  // Check if the read pointer has gone beyond the depth of&#xa;  // FIFO, so, set it back to the begining of the FIFO&#x9;&#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      // Reset the FIFO pointer&#xa;      rd_pointer &lt;= #`DEL `FIFO_BITS'b0;&#xa;    end &#xa;    else if ( ~read_n ) begin&#xa;      if ( rd_pointer == `FIFO_DEPTH ) begin&#xa;        rd_pointer &lt;= #`DEL `FIFO_BITS'b0; &#xa;      end &#xa;      else begin&#xa;        rd_pointer &lt;= #`DEL rd_pointer + 1;&#xa;      end &#xa;    end &#xa;    else begin&#xa;      rd_pointer &lt;= rd_pointer;&#xa;    end &#xa;  end&#xa;&#xa;  // Increment the write pointer&#xa;  // Check if the write pointer has gone beyond the depth of&#xa;  // FIFO, so, set it back to the begining of the FIFO&#x9;&#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      // Reset the FIFO pointer&#xa;      wr_pointer &lt;= #`DEL `FIFO_BITS'b0;&#xa;    end &#xa;    else if ( ~write_n ) begin&#xa;      if ( wr_pointer == `FIFO_DEPTH ) begin&#xa;        wr_pointer &lt;= #`DEL `FIFO_BITS'b0; &#xa;      end &#xa;      else begin &#xa;        wr_pointer &lt;= #`DEL wr_pointer + 1;&#xa;      end&#xa;    end&#xa;  end &#xa;&#xa;  // This block contains sfifo read data output &#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      data_out &lt;= #`DEL `FIFO_WIDTH'b0;&#xa;    end&#xa;    else if ( ~read_n )begin&#xa;      // Output the data&#xa;      data_out &lt;= #`DEL fifo_mem [ rd_pointer ];&#xa;    end&#xa;  end&#xa;&#xa;  // sfifo write operation&#xa;  always @( posedge clock ) begin&#xa;    if ( ~write_n )begin&#xa;      // Store the data&#xa;      fifo_mem [ wr_pointer ] &lt;= #`DEL data_in; &#xa;    end&#xa;  end&#xa;&#xa;  // This block contains all devices affected by the clock but not reset&#xa;  always @( posedge clock or negedge reset_n ) begin&#xa;    if ( ~reset_n ) begin&#xa;      data_out &lt;= #`DEL `FIFO_WIDTH'b0;&#xa;    end&#xa;    else if ( ~read_n )begin&#xa;      // Output the data&#xa;      data_out &lt;= #`DEL fifo_mem [ rd_pointer ];&#xa;    end&#xa;    if ( ~write_n )begin&#xa;      // Store the data&#xa;      fifo_mem [ wr_pointer ] &lt;= #`DEL data_in; &#xa;    end&#xa;  end&#xa;&#xa;&#xa;" Parent="uart_16550">
  <Port Height="20" Name="clock" Connect="" Side="left" Color="#0000ff" X="-0.166667" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.0892019" Inout="input" Parent="sfifo_tx"/>
  <Port Height="20" Name="reset_n" Connect="" Side="left" Color="#00ffff" X="-0.166667" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.234742" Inout="input" Parent="sfifo_tx"/>
  <Port Height="20" Name="data_in" Connect="" Side="left" Color="#7fffd4" X="-0.166667" Width="20" Function="" Datatype="wire" Datasize="8" Y="0.375587" Inout="input" Parent="sfifo_tx"/>
  <Port Height="20" Name="read_n" Connect="read_request" Side="left" Color="#006400" X="-0.166667" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.516432" Inout="input" Parent="sfifo_tx"/>
  <Port Height="20" Name="write_n" Connect="" Side="left" Color="#cd5c5c" X="-0.166667" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.657277" Inout="input" Parent="sfifo_tx"/>
  <Port Height="20" Name="data_out" Connect="" Side="right" Color="#ffe4c4" X="0.833333" Width="20" Function="" Datatype="reg" Datasize="8" Y="0.0892019" Inout="output" Parent="sfifo_tx"/>
  <Port Height="20" Name="full" Connect="" Side="right" Color="#b8860b" X="0.833333" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.234742" Inout="output" Parent="sfifo_tx"/>
  <Port Height="20" Name="empty" Connect="sfifo_tx_empty" Side="right" Color="#bdb76b" X="0.833333" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.375587" Inout="output" Parent="sfifo_tx"/>
  <Port Height="20" Name="half" Connect="" Side="right" Color="#0000ff" X="0.833333" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.516432" Inout="output" Parent="sfifo_tx"/>
  <Port Height="20" Name="counter" Connect="counter_of_tx" Side="right" Color="#8a2be2" X="0.833333" Width="20" Function="" Datatype="reg" Datasize="4" Y="0.657277" Inout="output" Parent="sfifo_tx"/>
 </Module>
 <Port Height="20" Name="clk" Side="left" Color="#0000ff" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.146832" Inout="input" Parent="uart_16550"/>
 <Port Height="20" Name="rst_n" Side="left" Color="#00ffff" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.310665" Inout="input" Parent="uart_16550"/>
 <Port Height="20" Name="data_in" Side="left" Color="#7fffd4" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="8" Y="0.474498" Inout="input" Parent="uart_16550"/>
 <Port Height="20" Name="write_n" Side="left" Color="#8a2be2" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.55796" Inout="input" Parent="uart_16550"/>
 <Port Height="20" Name="parity" Side="left" Color="#5f9ea0" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="3" Y="0.638331" Inout="input" Parent="uart_16550"/>
 <Port Height="20" Name="stop_bit" Side="left" Color="#ffe4c4" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="2" Y="0.721793" Inout="input" Parent="uart_16550"/>
 <Port Height="20" Name="data_bit" Side="left" Color="#b8860b" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="4" Y="0.802164" Inout="input" Parent="uart_16550"/>
 <Port Height="20" Name="baud_rate" Side="left" Color="#ffebcd" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="19" Y="0.394127" Inout="input" Parent="uart_16550"/>
 <Port Height="20" Name="tx" Side="right" Color="#0000ff" X="0.980769" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.230294" Inout="output" Parent="uart_16550"/>
 <Port Height="20" Name="tx_buf_full" Side="right" Color="#8a2be2" X="0.980769" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.108192" Inout="output" Parent="uart_16550"/>
 <Port Height="20" Name="rx" Side="left" Color="#a52a2a" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.0664606" Inout="input" Parent="uart_16550"/>
 <Port Height="20" Name="data_out" Side="right" Color="#deb887" X="0.980769" Width="20" Function="" Datatype="wire" Datasize="8" Y="0.72643" Inout="output" Parent="uart_16550"/>
 <Port Height="20" Name="empty" Side="right" Color="#5f9ea0" X="0.980769" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.355487" Inout="output" Parent="uart_16550"/>
 <Port Height="20" Name="full" Side="right" Color="#7fff00" X="0.980769" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.599691" Inout="output" Parent="uart_16550"/>
 <Port Height="20" Name="half_full" Side="right" Color="#d2691e" X="0.980769" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.477589" Inout="output" Parent="uart_16550"/>
 <Port Height="20" Name="read_n" Side="left" Color="#ff7f50" X="-0.0192308" Width="20" Function="" Datatype="wire" Datasize="1" Y="0.230294" Inout="input" Parent="uart_16550"/>
 <Wire From="uart_16550>rx" Name="uart_16550_rx" Datatype="wire" Datasize="1" To="uart_16550#uart1>rx" Parent="uart_16550"/>
 <Wire From="uart_16550>clk" Name="uart_16550_clk" Datatype="wire" Datasize="1" To="uart_16550#generate_clk1>clk" Parent="uart_16550"/>
 <Wire From="uart_16550#generate_clk1>clk_out" Name="generate_clk1_clk_out" Datatype="wire" Datasize="1" To="uart_16550#uart1>clk" Parent="uart_16550"/>
 <Wire From="uart_16550>rst_n" Name="uart_16550_rst_n" Datatype="wire" Datasize="1" To="uart_16550#generate_clk1>rst_n" Parent="uart_16550"/>
 <Wire From="uart_16550>rst_n" Name="uart_16550_rst_n" Datatype="wire" Datasize="1" To="uart_16550#uart1>rst_n" Parent="uart_16550"/>
 <Wire From="uart_16550>baud_rate" Name="uart_16550_baud_rate" Datatype="wire" Datasize="19" To="uart_16550#generate_clk1>baud_rate" Parent="uart_16550"/>
 <Wire From="uart_16550>parity" Name="uart_16550_parity" Datatype="wire" Datasize="3" To="uart_16550#uart1>parity" Parent="uart_16550"/>
 <Wire From="uart_16550>stop_bit" Name="uart_16550_stop_bit" Datatype="wire" Datasize="2" To="uart_16550#uart1>stop_bit" Parent="uart_16550"/>
 <Wire From="uart_16550>data_bit" Name="uart_16550_data_bit" Datatype="wire" Datasize="4" To="uart_16550#uart1>data_bit" Parent="uart_16550"/>
 <Wire From="uart_16550#uart1>tx_buf_full" Name="uart1_tx_buf_full" Datatype="wire" Datasize="1" To="uart_16550>tx_buf_full" Parent="uart_16550"/>
 <Wire From="uart_16550#uart1>tx" Name="uart1_tx" Datatype="wire" Datasize="1" To="uart_16550>tx" Parent="uart_16550"/>
 <Wire From="uart_16550#generate_clk1>clk_out" Name="generate_clk1_clk_out" Datatype="wire" Datasize="1" To="uart_16550#sfifo_rx>clock" Parent="uart_16550"/>
 <Wire From="uart_16550#generate_clk1>clk_out" Name="generate_clk1_clk_out" Datatype="wire" Datasize="1" To="uart_16550#sfifo_tx>clock" Parent="uart_16550"/>
 <Wire From="uart_16550>rst_n" Name="uart_16550_rst_n" Datatype="wire" Datasize="1" To="uart_16550#sfifo_tx>reset_n" Parent="uart_16550"/>
 <Wire From="uart_16550>rst_n" Name="uart_16550_rst_n" Datatype="wire" Datasize="1" To="uart_16550#sfifo_rx>reset_n" Parent="uart_16550"/>
 <Wire From="uart_16550>data_in" Name="uart_16550_data_in" Datatype="wire" Datasize="8" To="uart_16550#sfifo_tx>data_in" Parent="uart_16550"/>
 <Wire From="uart_16550>write_n" Name="uart_16550_write_n" Datatype="wire" Datasize="1" To="uart_16550#sfifo_tx>write_n" Parent="uart_16550"/>
 <Wire From="uart_16550#sfifo_tx>data_out" Name="sfifo_tx_data_out" Datatype="wire" Datasize="8" To="uart_16550#uart1>data_send" Parent="uart_16550"/>
 <Wire From="uart_16550#uart1>data_received" Name="uart1_data_received" Datatype="wire" Datasize="8" To="uart_16550#sfifo_rx>data_in" Parent="uart_16550"/>
 <Wire From="uart_16550#sfifo_rx>data_out" Name="sfifo_rx_data_out" Datatype="wire" Datasize="8" To="uart_16550>data_out" Parent="uart_16550"/>
 <Wire From="uart_16550#sfifo_rx>empty" Name="sfifo_rx_empty" Datatype="wire" Datasize="1" To="uart_16550>empty" Parent="uart_16550"/>
 <Wire From="uart_16550#sfifo_rx>full" Name="sfifo_rx_full" Datatype="wire" Datasize="1" To="uart_16550>full" Parent="uart_16550"/>
 <Wire From="uart_16550#sfifo_rx>half" Name="sfifo_rx_half" Datatype="wire" Datasize="1" To="uart_16550>half_full" Parent="uart_16550"/>
 <Wire From="uart_16550>read_n" Name="uart_16550_read_n" Datatype="wire" Datasize="1" To="uart_16550#sfifo_rx>read_n" Parent="uart_16550"/>
</Module>
