module generate_clk(
	clk,
	rst_n,
	baud_rate,
	clk_out);

	//---Ports declearation: generated by Robei---
	input clk;
	input rst_n;
	input [18:0] baud_rate;
	output clk_out;

	wire clk;
	wire rst_n;
	wire [18:0] baud_rate;
	wire clk_out;

	//----Code starts here: integrated by Robei-----
	parameter CLOCK = 12000000;  // This parameter is equal to the external crystal oscillator on FPGA 
	
	wire [`DIV_LENGTH-1:0] division;
	assign division = CLOCK / ( 16 * baud_rate );
	
	//
	// Even division, which duty is 50%
	//
	reg                       clk_even;
	reg     [`DIV_LENGTH-1:0] cnt_even;
	wire    [`DIV_LENGTH-1:0] division_even;
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    cnt_even <= #`DEL `DIV_LENGTH'd0;
	    clk_even <= #`DEL 1'b0;
	  end
	  else if( division[0]==1 ) begin
	    cnt_even <= #`DEL `DIV_LENGTH'd0;
	    clk_even <= #`DEL 1'b0;
	  end
	  else begin
	    if( cnt_even == ( division_even - 1 ) ) begin
	      cnt_even <= #`DEL `DIV_LENGTH'd0;
	      clk_even <= #`DEL ~clk_even;
	    end
	    else begin
	      cnt_even <= #`DEL cnt_even + 1'd1;
	      clk_even <= #`DEL clk_even;
	    end
	  end
	end     
	
	assign division_even = ( division[0] == 0 ) ? ( division >> 1 ) : 0;
	
	//
	// Odd division, which duty is 50%
	//
	reg                     clk_p;
	reg                     clk_n;
	wire                    clk_odd;
	reg   [`DIV_LENGTH-1:0] cnt_p;
	reg   [`DIV_LENGTH-1:0] cnt_n;
	wire  [`DIV_LENGTH-1:0] division_odd;
	
	//
	// Rising edge
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    clk_p <= #`DEL 1'b0;
	    cnt_p <= #`DEL `DIV_LENGTH'b0;
	  end
	  else if( division[0]==0 ) begin    
	    clk_p <= #`DEL 1'b0;
	    cnt_p <= #`DEL `DIV_LENGTH'b0;
	  end
	  else begin
	    if( cnt_p == division_odd - 1 ) begin
	      clk_p <= #`DEL ~clk_p;
	      cnt_p <= #`DEL `DIV_LENGTH'b0;
	    end
	    else if( cnt_p == ( ( division - 1 ) >> 1 ) )begin
	      clk_p <= #`DEL ~clk_p;
	      cnt_p <= #`DEL cnt_p + 1'b1;
	    end
	    else begin
	      clk_p <= #`DEL clk_p;
	      cnt_p <= #`DEL cnt_p + 1'b1;
	    end
	  end
	end      
	
	//
	// Falling edge
	always @( negedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    clk_n <= #`DEL 1'b0;
	    cnt_n <= #`DEL `DIV_LENGTH'b0;
	  end
	  else if( division[0] == 0 ) begin    
	    clk_n <= #`DEL 1'b0;
	    cnt_n <= #`DEL `DIV_LENGTH'b0;
	  end
	  else begin
	    if( cnt_n == division_odd - 1 ) begin
	      clk_n <= #`DEL ~clk_n;
	      cnt_n <= #`DEL `DIV_LENGTH'b0;
	    end
	    else if( cnt_n == ( ( division - 1 ) >> 1 ) )begin
	      clk_n <= #`DEL ~clk_n;
	      cnt_n <= #`DEL cnt_n + `DIV_LENGTH'b1;
	    end
	    else begin
	      clk_n <= #`DEL clk_n;
	      cnt_n <= #`DEL cnt_n + `DIV_LENGTH'b1;
	    end
	  end
	end     
	
	
	assign division_odd = ( division[0] == 1 ) ? division : 0;
	assign clk_odd = clk_n | clk_p;
	
	assign clk_out = ( division[0] == 1 ) ? clk_odd : clk_even;
endmodule    //generate_clk

