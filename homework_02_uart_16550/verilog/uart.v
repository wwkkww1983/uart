module uart(
	clk,
	rst_n,
	rx,
	tx_en,
	data_send,
	parity,
	stop_bit,
	data_bit,
	tx_buf_full,
	tx,
	data_received,
	rx_buf_full);

	//---Ports declearation: generated by Robei---
	input clk;
	input rst_n;
	input rx;
	input tx_en;
	input [7:0] data_send;
	input [2:0] parity;
	input [1:0] stop_bit;
	input [3:0] data_bit;
	output tx_buf_full;
	output tx;
	output [7:0] data_received;
	output rx_buf_full;

	wire clk;
	wire rst_n;
	wire rx;
	wire tx_en;
	wire [7:0] data_send;
	wire [2:0] parity;
	wire [1:0] stop_bit;
	wire [3:0] data_bit;
	reg tx_buf_full;
	reg tx;
	reg [7:0] data_received;
	reg rx_buf_full;

	//----Code starts here: integrated by Robei-----
	//
	// Parity is equal to 0 means that there should not have parity bit. Otherwise, there should be one parity bit.
	//
	wire       parity_bit;
	assign parity_bit = ( ~|parity ) ? 0 : 1; 
	
	//
	// This block is used to receive data
	//
	
	//
	// Edge deteted
	//
	
	reg                     rx_q;
	wire                    rx_start;
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    rx_q <= #`DEL 1'b0;
	  end
	  else begin
	    rx_q <= #`DEL rx;
	  end
	end      
	// Falling edge effective
	assign rx_start = ( rx_q && ~rx );
	
	//
	// Counter of rx
	//
	
	reg  [7:0]  rx_cnt;
	
	always @( posedge clk or negedge rst_n ) begin
	  if ( ~rst_n ) begin
	    rx_cnt <= #`DEL 8'd0;
	  end
	  else if ( ns_rx == IDLE_RX || ns_rx == ERROR_RX ) begin
	    rx_cnt <= #`DEL 8'd0;
	  end  // If the next status is IDLE or ERROR, then don't count
	  else begin
	    rx_cnt <= #`DEL rx_cnt + 1'd1;
	  end  // If the next status is not IDLE or ERROR, then begin to count
	end
	
	//
	// Three paragraph FSM of receive 
	//
	reg       [3:0]   cs_rx;
	reg       [3:0]   ns_rx;
	parameter [3:0]   IDLE_RX   = 4'b0000,
	  START_RX     = 4'b0001,
	  RECEIVE_RX   = 4'b0010,
	  STOP_RX      = 4'b0100,
	  ERROR_RX     = 4'b1000;
	
	// FSM one
	//
	always @( posedge clk or negedge rst_n ) begin
	  if ( !rst_n ) begin
	    cs_rx <= IDLE_RX;
	  end
	  else begin
	    cs_rx <= ns_rx;
	  end
	end
	
	
	// FSM two
	//
	
	// cnt_parity_rx means that rx_cnt has counted to the parity bit
	wire [7:0] cnt_parity_rx;
	assign cnt_parity_rx = ( 24 + ( data_bit + parity_bit ) * 16 ); 
	
	always @( * ) begin
	  ns_rx = IDLE_RX;
	  case ( cs_rx )
	    IDLE_RX: begin
	      if( rx_start ) begin
	        ns_rx = START_RX;  // If there has a falling edge in rx, then transmit to START
	      end
	      else begin
	        ns_rx = IDLE_RX;
	      end
	    end
	    START_RX: begin 
	      if ( rx && rx_cnt < 8 ) begin
	        ns_rx = ERROR_RX;  // If rx has a high volage in START status, there must be an error
	      end 
	      else if( rx_cnt == 8 ) begin 
	        ns_rx = RECEIVE_RX;  // If rx can remain low volage for 8 cycles, we believe communication is correct, then begin to receive data
	      end
	      else begin 
	        ns_rx = START_RX; 
	      end
	    end
	    RECEIVE_RX: begin
	      if ( rx_cnt == cnt_parity_rx ) begin
	        ns_rx = STOP_RX;
	      end 
	      else begin 
	        ns_rx = RECEIVE_RX;
	      end
	    end 
	    STOP_RX: begin
	      if( rx_cnt == cnt_parity_rx + ( stop_bit * 16 ) ) begin
	        ns_rx = IDLE_RX;
	      end
	      else begin
	        ns_rx = STOP_RX;
	      end
	    end
	    ERROR_RX: begin 
	      ns_rx = IDLE_RX; 
	    end 
	    default: begin
	      ns_rx = ns_rx;
	    end
	  endcase
	end
	
	// FSM three
	//
	
	reg [3:0] count_cycle_rx; // Used to count the bit num of received data
	reg [8:0] data_received_temp;
	
	always @( posedge clk or negedge rst_n ) begin 
	  if ( !rst_n ) begin 
	    data_received_temp <= #`DEL 9'd0;
	    rx_buf_full        <= #`DEL 1'b0;
	    count_cycle_rx     <= #`DEL 4'd1;
	  end
	  else begin 
	    case ( ns_rx )
	      IDLE_RX: begin
	        data_received_temp <= #`DEL 9'd0;
	        rx_buf_full        <= #`DEL 1'b0;
	        count_cycle_rx     <= #`DEL 4'd1;
	      end
	      START_RX: begin
	        data_received_temp <= #`DEL 9'd0;
	        rx_buf_full        <= #`DEL 1'b0;
	        count_cycle_rx     <= #`DEL 4'd1;
	      end
	      RECEIVE_RX: begin
	        if( count_cycle_rx == ( data_bit + parity_bit ) && ( rx_cnt == 24 + 16 * ( count_cycle_rx - 1 ) ) ) begin
	          data_received_temp[count_cycle_rx - 1] <= #`DEL rx;  // Parity check bit
	          rx_buf_full                            <= #`DEL 1'b0;
	          count_cycle_rx                         <= #`DEL 4'd1; // Reset count_cycle_rx 
	        end  // Receive parity check bit
	        else if( rx_cnt == ( 24 + ( count_cycle_rx - 1 ) * 16 - 8 ) ) begin
	          data_received_temp[count_cycle_rx - 1] <= #`DEL rx;
	          rx_buf_full                            <= #`DEL 1'b0;
	          count_cycle_rx                         <= #`DEL count_cycle_rx + 1'b1;
	        end  // Data bit
	      end
	      STOP_RX: begin
	        if( rx_cnt == cnt_parity_rx + ( stop_bit * 16 ) - 8 ) begin  // -8 is to catch the stop bit
	          data_received_temp <= #`DEL data_received_temp;
	          rx_buf_full        <= #`DEL 1'b1;
	          count_cycle_rx     <= #`DEL count_cycle_rx;
	        end
	      end
	      ERROR_RX: begin        
	        data_received_temp <= #`DEL 9'd0;
	        rx_buf_full        <= #`DEL 1'b0;
	        count_cycle_rx     <= #`DEL 4'd1; 
	      end
	    endcase 
	  end 
	end  
	
	reg [8:0] data_received_check;
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    case( parity )
	      3'b000:begin
	        data_received_check <= #`DEL 9'b0_0000_0000;
	      end  // If parity is equal to 3'b000, then there should not be parity check bit
	      3'b001:begin
	        data_received_check <= #`DEL 9'b1_0000_0000;
	      end  // Odd check init
	      3'b010:begin
	        data_received_check <= #`DEL 9'b0_0000_0000;
	      end  // Even check init
	      3'b011:begin
	        data_received_check <= #`DEL 9'b0_0000_0000;
	      end  // Zero check init
	      3'b100:begin
	        data_received_check <= #`DEL 9'b1_0000_0000;
	      end  // One check init
	    endcase
	  end
	  else if( ns_rx == STOP_RX ) begin
	    data_received_check <= #`DEL data_received_temp;  // Ensure data can be collected
	  end
	end           
	
	/*
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    data_received = 8'd0;
	  end
	  else begin
	    case( parity )
	      3'b000:begin
	        data_received = data_received_check[7:0];
	      end  // If parity is equal to 3'b000, then there should not be parity check bit
	      3'b001:begin
	        if( data_received_check[8] == ( ~( ^data_received_check[7:0] ) ) ) begin
	          data_received = data_received_check[7:0];
	        end
	        else begin
	          $display( "UART line 254: Odd check error!" );
	          $display( "data_received_check=9'b%b_%b_%b",data_received_check[8],data_received_check[7:4],data_received_check[3:0] );
	          $display( "data_received_check[8]=%b, ~^data_received_check[7:0]=%b", data_received_check[8],~^data_received_check[7:0] );
	          $finish;
	        end 
	      end
	      3'b010:begin
	        if( data_received_check[8] == ^data_received_check[7:0] ) begin
	          data_received = data_received_check[7:0];
	        end
	        else begin
	          $display( "UART line 265: Even check error!" );
	          $display( "data_received=9'b%b_%b_%b",data_received_check[8],data_received_check[7:4],data_received_check[3:0] );
	          $display( "data_received_check[8]=%b, ~^data_received_check[7:0]=%b", data_received_check[8],~^data_received_check[7:0] );
	          $finish;
	        end
	      end
	      3'b011:begin
	        if( data_received_check[8] == 0 ) begin
	          data_received = data_received_check[7:0];
	        end
	        else begin
	          $display( "UART line 275: Zero check error!" );
	          $display( "data_received=9'b%b_%b_%b",data_received_check[8],data_received_check[7:4],data_received_check[3:0] );
	          $display( "data_received_check[8]=%b, ~^data_received_check[7:0]=%b", data_received_check[8],~^data_received_check[7:0] );
	          $finish;
	        end
	      end
	      3'b100:begin
	        if( data_received_check[8] == 1 ) begin
	          data_received = data_received_check[7:0];
	        end
	        else begin
	          $display( "UART line 285: One check error!" );
	          $display( "data_received=9'b%b_%b_%b",data_received_check[8],data_received_check[7:4],data_received_check[3:0] );
	          $display( "data_received_check[8]=%b, ~^data_received_check[7:0]=%b", data_received_check[8],~^data_received_check[7:0] );
	          $finish;
	        end
	      end
	    endcase
	  end
	end      
	*/
	
	//
	// This block is used to send data
	//
	
	// 
	// Edge deteted
	//
	
	reg         tx_en_q;
	wire        tx_start;
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    tx_en_q <= #`DEL 1'b0;
	  end
	  else begin
	    tx_en_q <= #`DEL tx_en;
	  end
	end      
	// Rising edge effective
	assign tx_start = ( ~tx_en_q && tx_en );
	
	//
	// Transmit data_send to shift_reg
	//
	
	reg  [8:0]  shift_reg;
	
	always @( posedge tx_start or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    shift_reg <= #`DEL 9'd0;
	  end
	  else begin
	    shift_reg[7:0] <= #`DEL data_send;
	    //
	    // Parity check bit
	    case( parity )
	      3'b000: shift_reg[8]   <= #`DEL 0;   // No parity check
	      3'b001: shift_reg[8]   <= #`DEL ( ^data_send ) ? 0 : 1;  // Odd check
	      3'b010: shift_reg[8]   <= #`DEL ( ^data_send ) ? 1 : 0;  // Even check
	      3'b011: shift_reg[8]   <= #`DEL 0;  // 0 check
	      3'b100: shift_reg[8]   <= #`DEL 1;  // 1 check
	    endcase
	  end
	end      
	
	//
	// Frequence division
	//
	
	reg  [7:0]  tx_cnt;
	
	always @( posedge clk or negedge rst_n ) begin
	  if ( ~rst_n ) begin
	    tx_cnt <= #`DEL 8'd0;
	  end
	  else if ( ns_tx == IDLE_TX ) begin
	    tx_cnt <= #`DEL 8'd0;
	  end
	  else begin
	    tx_cnt <= #`DEL tx_cnt + 1'b1;
	  end
	end
	
	//
	// Three paragraph FSM of send data
	//
	reg       [2:0]   cs_tx;
	reg       [2:0]   ns_tx;
	parameter [2:0]  IDLE_TX   = 3'b000,
	  START_TX     = 3'b001,
	  SEND_TX      = 3'b010,
	  STOP_TX      = 3'b100;
	
	//
	// FSM one
	always @( posedge clk or negedge rst_n ) begin
	  if ( !rst_n ) begin
	    cs_tx <= IDLE_TX;
	  end
	  else begin
	    cs_tx <= ns_tx;
	  end
	end
	
	// 
	// FSM two
	
	// cnt_parity_tx means that tx_cnt has counted to the parity bit
	wire [7:0] cnt_parity_tx;
	assign cnt_parity_tx = ( data_bit + parity_bit + 1 ) * 16;   // +1 is means to add the start bit
	
	always @( * ) begin
	  ns_tx = IDLE_TX;
	  case ( cs_tx )
	    IDLE_TX: begin
	      if ( tx_start ) begin
	        ns_tx = START_TX;
	      end
	      else begin
	        ns_tx = IDLE_TX;
	      end
	    end
	    START_TX: begin
	      ns_tx = SEND_TX;
	    end 
	    SEND_TX: begin 
	      if ( tx_cnt == cnt_parity_tx ) begin
	        ns_tx = STOP_TX; 
	      end 
	      else begin 
	        ns_tx = SEND_TX;
	      end
	    end
	    STOP_TX: begin 
	      if ( tx_cnt == cnt_parity_tx + stop_bit * 16 ) begin
	        ns_tx = IDLE_TX; 
	      end
	      else begin
	        ns_tx = STOP_TX;
	      end
	    end
	    default: begin
	      ns_tx = ns_tx;
	    end
	  endcase 
	end
	
	 
	// FSM three 
	//
	
	reg [3:0] count_cycle_tx; // Used to count the bit num of send data
	
	always @( posedge clk or negedge rst_n ) begin 
	  if ( !rst_n ) begin 
	    tx          <= #`DEL 1'b1;
	    tx_buf_full <= #`DEL 1'b0;
	  end
	  else begin 
	    case ( ns_tx )
	      IDLE_TX: begin
	        tx             <= #`DEL 1'b1;
	        tx_buf_full    <= #`DEL 1'b0;
	        count_cycle_tx <= #`DEL 4'd1;
	      end
	      START_TX: begin
	        tx             <= #`DEL 1'b0;
	        tx_buf_full    <= #`DEL 1'b0;
	        count_cycle_tx <= #`DEL 4'd1;
	      end
	      SEND_TX: begin
	        if( ( count_cycle_tx == parity_bit + data_bit ) && ( tx_cnt == 16 * ( count_cycle_tx ) ) ) begin
	          tx             <= #`DEL shift_reg[count_cycle_tx-1];
	          tx_buf_full    <= #`DEL 1'b1;
	          count_cycle_tx <= #`DEL 4'd1;
	        end
	        else if( tx_cnt == 16 * count_cycle_tx ) begin
	          tx             <= #`DEL shift_reg[count_cycle_tx-1];
	          tx_buf_full    <= #`DEL 1'b1;
	          count_cycle_tx <= #`DEL count_cycle_tx + 1'b1;
	        end
	      end
	      STOP_TX: begin
	        if( tx_cnt == cnt_parity_tx + ( stop_bit ) * 16 ) begin // If it is ( stop_bit - 1 ) ,then the tx_buf_full will active advance that isn't what our want.
	          tx             <= #`DEL 1'b1;
	          tx_buf_full    <= #`DEL 1'b0;
	          count_cycle_tx <= #`DEL 4'd1;
	        end
	      end
	    endcase 
	  end 
	end      
	
endmodule    //uart

