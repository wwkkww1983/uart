module divider(
	clk,
	rst_n,
	start_sig,
	dividend,
	divisor,
	done_sig,
	quotient,
	remainder);

	//---Ports declearation: generated by Robei---
	input clk;
	input rst_n;
	input start_sig;
	input [7:0] dividend;
	input [7:0] divisor;
	output done_sig;
	output [7:0] quotient;
	output [7:0] remainder;

	wire clk;
	wire rst_n;
	wire start_sig;
	wire [7:0] dividend;
	wire [7:0] divisor;
	wire done_sig;
	wire [7:0] quotient;
	wire [7:0] remainder;

	//----Code starts here: integrated by Robei-----
	reg[3:0] i;
	reg[7:0] dsor;
	reg[7:0] rd;
	reg[7:0] dend;
	reg[7:0] qent;
	reg isneg;
	reg isdone;
	always @(posedge clk or negedge rst_n)
	if(!rst_n)
	begin
	i<=4'd0;
	dend<=8'd0;
	dsor<=8'd0;
	rd<=8'd0;
	qent<=8'd0;
	isneg<=1'b0;
	isdone<=1'b0;
	end
	else if(start_sig)
	case(i)
	0: begin
	dend<=dividend[7]?~dividend+1:dividend;
	dsor<=divisor[7]?~divisor+1:divisor;
	rd<=divisor[7]?divisor:(~divisor+1);
	isneg<=dividend[7]^divisor[7];
	qent<=8'd0;
	i<=i+1;
	end
	1: begin
	if(dend<dsor)
	begin
	qent<=isneg?(~qent+1):qent;
	i<=i+1;
	end
	else
	begin
	dend<=dend+rd;
	qent<=qent+1;
	end
	end
	2:begin
	isdone<=1'b1;
	i<=i+1;
	end
	3:begin
	isdone<=1'b0;
	i<=4'd0;
	end
	endcase
	assign done_sig=isdone;
	assign quotient=qent;
	assign remainder=dend;
	
	
	
endmodule    //divider

