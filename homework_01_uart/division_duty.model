<!DOCTYPE Robei>
<Module Code="`define DEL 1&#xa;&#xa;//&#xa;// There should be two datas to control frequency division and duty seperately&#xa;// The first data is to control the division, while the second control the duty&#xa;//&#xa;reg [7:0] division;&#xa;reg [7:0] duty_num;&#xa;&#xa;assign division_num = division;  // Used as output for low level( flashed module ) use&#xa;&#xa;//&#xa;// Detect the falling edge of data_en&#xa;reg     data_en_q;&#xa;wire    data_en_flag;&#xa;reg     cnt_div_duty;&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    data_en_q &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else begin&#xa;    data_en_q &lt;= #`DEL data_en;&#xa;  end&#xa;end&#xa;assign data_en_flag = ( data_en_q ) &amp;&amp; ( ~data_en );&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    division     &lt;= #`DEL 8'd0;&#xa;    duty_num     &lt;= #`DEL 8'd0;&#xa;    cnt_div_duty &lt;= #`DEL 1'd1;&#xa;  end&#xa;  else if( data_en_flag ) begin&#xa;    case( cnt_div_duty )&#xa;      1:begin&#xa;        division     &lt;= #`DEL data_in[7:0];&#xa;        duty_num     &lt;= #`DEL duty_num;&#xa;        cnt_div_duty &lt;= #`DEL cnt_div_duty + 1'b1;&#xa;      end&#xa;      0:begin&#xa;        division     &lt;= #`DEL division;&#xa;        duty_num     &lt;= #`DEL data_in[7:0];&#xa;        cnt_div_duty &lt;= #`DEL cnt_div_duty + 1'b1;&#xa;      end&#xa;    endcase&#xa;  end&#xa;end &#xa;&#xa;//&#xa;// Parity check&#xa;//&#xa;always @( posedge clk ) begin&#xa;  if( data_in[8] != ^data_in[7:0] ) begin&#xa;    $display( &quot; Division_duty:Uart communication error! &quot; );&#xa;    $display(&quot;Receive data is: 9'b%b_%b_%b&quot;,data_in[8],data_in[7:4],data_in[3:0]);&#xa;    $display(&quot;data_in[8] = 1'b%b, ^data_in[7:0] = 1'b%b&quot;,data_in[8],^data_in[7:0]);&#xa;    $finish;&#xa;  end&#xa;end      &#xa;&#xa;//&#xa;// Even division, which duty is 50%&#xa;//&#xa;reg           clk_even;&#xa;wire          clk_out_div;&#xa;reg     [7:0] cnt_even;&#xa;wire    [7:0] division_even;&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    cnt_even &lt;= #`DEL 8'd0;&#xa;    clk_even &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else if( division[0]==1 || ~cnt_div_duty ) begin&#xa;    cnt_even &lt;= #`DEL 8'd0;&#xa;    clk_even &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else begin&#xa;    if( division[7:0] == 8'd0 ) begin    &#xa;      cnt_even &lt;= #`DEL 8'd0;&#xa;    end&#xa;    else if( cnt_even == ( division_even - 1 ) ) begin&#xa;      cnt_even &lt;= #`DEL 8'd0;&#xa;      clk_even &lt;= #`DEL ~clk_even;&#xa;    end&#xa;    else begin&#xa;      cnt_even &lt;= #`DEL cnt_even + 8'd1;&#xa;      clk_even &lt;= #`DEL clk_even;&#xa;    end&#xa;  end&#xa;end     &#xa;&#xa;assign division_even = ( division[0] == 0 ) ? ( division[7:0] >> 1 ) : 0;&#xa;&#xa;//&#xa;// Odd division, which duty is 50%&#xa;//&#xa;reg         clk_p;&#xa;reg         clk_n;&#xa;wire        clk_odd;&#xa;reg   [7:0] cnt_p;&#xa;reg   [7:0] cnt_n;&#xa;wire  [7:0] division_odd;&#xa;&#xa;//&#xa;// Rising edge&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    clk_p &lt;= #`DEL 1'b0;&#xa;    cnt_p &lt;= #`DEL 8'b0;&#xa;  end&#xa;  else if( division[0]==0 || ~cnt_div_duty ) begin    &#xa;    clk_p &lt;= #`DEL 1'b0;&#xa;    cnt_p &lt;= #`DEL 8'b0;&#xa;  end&#xa;  else begin&#xa;    if( cnt_p == division_odd - 1 ) begin&#xa;      clk_p &lt;= #`DEL ~clk_p;&#xa;      cnt_p &lt;= #`DEL 8'b0;&#xa;    end&#xa;    else if( cnt_p == ( ( division[7:0] - 1 ) >> 1 ) )begin&#xa;      clk_p &lt;= #`DEL ~clk_p;&#xa;      cnt_p &lt;= #`DEL cnt_p + 8'b1;&#xa;    end&#xa;    else begin&#xa;      clk_p &lt;= #`DEL clk_p;&#xa;      cnt_p &lt;= #`DEL cnt_p + 8'b1;&#xa;    end&#xa;  end&#xa;end      &#xa;&#xa;//&#xa;// Falling edge&#xa;always @( negedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    clk_n &lt;= #`DEL 1'b0;&#xa;    cnt_n &lt;= #`DEL 8'b0;&#xa;  end&#xa;  else if( division[0]==0 || ~cnt_div_duty ) begin    &#xa;    clk_n &lt;= #`DEL 1'b0;&#xa;    cnt_n &lt;= #`DEL 8'b0;&#xa;  end&#xa;  else begin&#xa;    if( cnt_n == division_odd - 1 ) begin&#xa;      clk_n &lt;= #`DEL ~clk_n;&#xa;      cnt_n &lt;= #`DEL 8'b0;&#xa;    end&#xa;    else if( cnt_n == ( ( division[7:0] - 1 ) >> 1 ) )begin&#xa;      clk_n &lt;= #`DEL ~clk_n;&#xa;      cnt_n &lt;= #`DEL cnt_n + 8'b1;&#xa;    end&#xa;    else begin&#xa;      clk_n &lt;= #`DEL clk_n;&#xa;      cnt_n &lt;= #`DEL cnt_n + 8'b1;&#xa;    end&#xa;  end&#xa;end     &#xa;&#xa;&#xa;assign division_odd = ( division[0] == 1 ) ? division[7:0] : 0;&#xa;assign clk_odd = clk_n | clk_p;&#xa;&#xa;assign clk_out_div = ( division[0] == 1 ) ? clk_odd : clk_even;&#xa;&#xa;//&#xa;// Duty&#xa;//&#xa;reg [7:0] cnt_duty; // Used in duty generate&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    cnt_duty &lt;= #`DEL 8'd0;&#xa;  end&#xa;  else if( ( duty_num == (division[7:0]>>1) ) || cnt_duty_flag || ~cnt_div_duty ) begin&#xa;    // If duty is half of division[7:0] that means duty is 50%,&#xa;    // use clk_div as clk_out&#xa;    // If cnt_duty_flag is 1, then count begin from 0&#xa;    cnt_duty &lt;= #`DEL 8'd0;&#xa;  end&#xa;  else if( cnt_duty == division[7:0] )begin&#xa;    cnt_duty &lt;= #`DEL 8'd0;&#xa;  end&#xa;  else begin&#xa;    cnt_duty &lt;= #`DEL cnt_duty + 8'd1;&#xa;  end&#xa;end      &#xa;&#xa;//&#xa;// Attention: duty_num is an input signal, which is equal to duty(%) * division&#xa;reg clk_out_duty;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    clk_out_duty &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else if( duty_num == (division[7:0]>>1) || cnt_duty_flag || ~cnt_div_duty ) begin&#xa;    clk_out_duty &lt;= #`DEL 1'b0;&#xa;  end&#xa;  else if( cnt_duty &lt; duty_num )begin&#xa;    clk_out_duty &lt;= #`DEL 1'b1;&#xa;  end&#xa;  else begin&#xa;    clk_out_duty &lt;= #`DEL 1'b0;&#xa;  end&#xa;end      &#xa;&#xa;// While duty_num is half of division which means duty is 50%, clk_out is generated by the first method that is more accurate than the second method&#xa;// While duty is not 50%,clk_out is generated by the 2nd way which duty is variable&#xa;assign clk_out = ( duty_num == (division[7:0]>>1) || duty_num == 0 ) ? clk_out_div : clk_out_duty;&#xa;&#xa;//&#xa;// Detect the change of duty_num and division&#xa;//&#xa;reg [7:0]  duty_num_temp;&#xa;reg [7:0]  division_temp;&#xa;reg        duty_num_flag;&#xa;reg        division_flag;&#xa;reg        cnt_duty_flag;&#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    duty_num_temp &lt;= #`DEL 8'd0;&#xa;  end&#xa;  else begin&#xa;    duty_num_temp &lt;= #`DEL duty_num;&#xa;  end&#xa;end      &#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    division_temp &lt;= #`DEL 8'd0;&#xa;  end&#xa;  else begin&#xa;    division_temp &lt;= #`DEL division;&#xa;  end&#xa;end &#xa;&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    duty_num_flag &lt;= #`DEL 1'd0;&#xa;    division_flag &lt;= #`DEL 1'd0;&#xa;  end&#xa;  else if( duty_num_temp != duty_num )begin&#xa;    duty_num_flag &lt;= #`DEL 1'd1;&#xa;  end&#xa;  else if( division_temp != division )begin&#xa;    division_flag &lt;= #`DEL 1'd1;&#xa;  end&#xa;  else begin &#xa;    duty_num_flag &lt;= #`DEL 1'd0;&#xa;    division_flag &lt;= #`DEL 1'd0;&#xa;  end&#xa;end      &#xa;&#xa;//&#xa;// Generate the start counting signal of cnt_duty. If cnt_duty_flag is 1, which means division or duty_num has changed, then cnt_duty start count from 0 again&#xa;always @( posedge clk or negedge rst_n ) begin&#xa;  if( ~rst_n ) begin&#xa;    cnt_duty_flag &lt;= #`DEL 1'd0;&#xa;  end&#xa;  else if( duty_num_flag || division_flag )begin&#xa;    cnt_duty_flag &lt;= #`DEL 1'd1;&#xa;  end&#xa;  else begin&#xa;    cnt_duty_flag &lt;= #`DEL 1'd0;&#xa;  end&#xa;end &#xa;&#xa;" X="0" Name="division_duty" Class="module" Parameters="" Width="839" Include="" Parent="0" Comment="" Color="#d3d3d3" Height="457" Y="142.339" File="Current/division_duty.model" Type="module">
 <Port Datasize="1" Function="" X="-0.0238379" Name="clk" Inout="input" Width="20" Parent="division_duty" Color="#0000ff" Height="20" Y="0.142232" Side="left" Datatype="wire"/>
 <Port Datasize="1" Function="" X="-0.0238379" Name="rst_n" Inout="input" Width="20" Parent="division_duty" Color="#00ffff" Height="20" Y="0.308534" Side="left" Datatype="wire"/>
 <Port Datasize="1" Function="" X="0.976162" Name="clk_out" Inout="output" Width="20" Parent="division_duty" Color="#a52a2a" Height="20" Y="0.225383" Side="right" Datatype="wire"/>
 <Port Datasize="9" Function="" X="-0.0238379" Name="data_in" Inout="input" Width="20" Parent="division_duty" Color="#7fff00" Height="20" Y="0.641138" Side="left" Datatype="wire"/>
 <Port Datasize="1" Function="" X="-0.0238379" Name="data_en" Inout="input" Width="20" Parent="division_duty" Color="#ff1493" Height="20" Y="0.474836" Side="left" Datatype="wire"/>
 <Port Datasize="8" Function="" X="0.976162" Name="division_num" Inout="output" Width="20" Parent="division_duty" Color="#00bfff" Height="20" Y="0.474836" Side="right" Datatype="wire"/>
</Module>
