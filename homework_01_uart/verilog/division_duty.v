module division_duty(
	clk,
	rst_n,
	clk_out,
	data_in,
	data_en);

	//---Ports declearation: generated by Robei---
	input clk;
	input rst_n;
	output clk_out;
	input [8:0] data_in;
	input data_en;

	wire clk;
	wire rst_n;
	wire clk_out;
	wire [8:0] data_in;
	wire data_en;

	//----Code starts here: integrated by Robei-----
	`define DEL 1
	
	//
	// There should be two datas to control frequency division and duty seperately
	// The first data is to control the division, while the second control the duty
	//
	reg [7:0] division;
	reg [7:0] duty_num;
	
	//
	// Detect the falling edge of data_en
	reg     data_en_q;
	wire    data_en_flag;
	reg     cnt_div_duty;
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    data_en_q <= #`DEL 1'b0;
	  end
	  else begin
	    data_en_q <= #`DEL data_en;
	  end
	end
	assign data_en_flag = ( data_en_q ) && ( ~data_en );
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    division     <= #`DEL 8'd0;
	    duty_num     <= #`DEL 8'd0;
	    cnt_div_duty <= #`DEL 1'd1;
	  end
	  else if( data_en_flag ) begin
	    case( cnt_div_duty )
	      1:begin
	        division     <= #`DEL data_in[7:0];
	        duty_num     <= #`DEL duty_num;
	        cnt_div_duty <= #`DEL cnt_div_duty + 1'b1;
	      end
	      0:begin
	        division     <= #`DEL division;
	        duty_num     <= #`DEL data_in[7:0];
	        cnt_div_duty <= #`DEL cnt_div_duty + 1'b1;
	      end
	    endcase
	  end
	end 
	
	//
	// Parity check
	//
	always @( posedge clk ) begin
	  if( data_in[8] != ^data_in[7:0] ) begin
	    $display( " Division_duty:Uart communication error! " );
	    $display("Receive data is: 9'b%b_%b_%b",data_in[8],data_in[7:4],data_in[3:0]);
	    $finish;
	  end
	end      
	
	//
	// Even division, which duty is 50%
	//
	reg           clk_even;
	wire          clk_out_div;
	reg     [7:0] cnt_even;
	wire    [7:0] division_even;
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    cnt_even <= #`DEL 8'd0;
	    clk_even <= #`DEL 1'b0;
	  end
	  else if( division[0]==1 || ~cnt_div_duty ) begin
	    cnt_even <= #`DEL 8'd0;
	    clk_even <= #`DEL 1'b0;
	  end
	  else begin
	    if( division[7:0] == 8'd0 ) begin    
	      cnt_even <= #`DEL 8'd0;
	    end
	    else if( cnt_even == ( division_even - 1 ) ) begin
	      cnt_even <= #`DEL 8'd0;
	      clk_even <= #`DEL ~clk_even;
	    end
	    else begin
	      cnt_even <= #`DEL cnt_even + 8'd1;
	      clk_even <= #`DEL clk_even;
	    end
	  end
	end     
	
	assign division_even = ( division[0] == 0 ) ? ( division[7:0] >> 1 ) : 0;
	
	//
	// Odd division, which duty is 50%
	//
	reg         clk_p;
	reg         clk_n;
	wire        clk_odd;
	reg   [7:0] cnt_p;
	reg   [7:0] cnt_n;
	wire  [7:0] division_odd;
	
	//
	// Rising edge
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    clk_p <= #`DEL 1'b0;
	    cnt_p <= #`DEL 8'b0;
	  end
	  else if( division[0]==0 || ~cnt_div_duty ) begin    
	    clk_p <= #`DEL 1'b0;
	    cnt_p <= #`DEL 8'b0;
	  end
	  else begin
	    if( cnt_p == division_odd - 1 ) begin
	      clk_p <= #`DEL ~clk_p;
	      cnt_p <= #`DEL 8'b0;
	    end
	    else if( cnt_p == ( ( division[7:0] - 1 ) >> 1 ) )begin
	      clk_p <= #`DEL ~clk_p;
	      cnt_p <= #`DEL cnt_p + 8'b1;
	    end
	    else begin
	      clk_p <= #`DEL clk_p;
	      cnt_p <= #`DEL cnt_p + 8'b1;
	    end
	  end
	end      
	
	//
	// Falling edge
	always @( negedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    clk_n <= #`DEL 1'b0;
	    cnt_n <= #`DEL 8'b0;
	  end
	  else if( division[0]==0 || ~cnt_div_duty ) begin    
	    clk_n <= #`DEL 1'b0;
	    cnt_n <= #`DEL 8'b0;
	  end
	  else begin
	    if( cnt_n == division_odd - 1 ) begin
	      clk_n <= #`DEL ~clk_n;
	      cnt_n <= #`DEL 8'b0;
	    end
	    else if( cnt_n == ( ( division[7:0] - 1 ) >> 1 ) )begin
	      clk_n <= #`DEL ~clk_n;
	      cnt_n <= #`DEL cnt_n + 8'b1;
	    end
	    else begin
	      clk_n <= #`DEL clk_n;
	      cnt_n <= #`DEL cnt_n + 8'b1;
	    end
	  end
	end     
	
	
	assign division_odd = ( division[0] == 1 ) ? division[7:0] : 0;
	assign clk_odd = clk_n | clk_p;
	
	assign clk_out_div = ( division[0] == 1 ) ? clk_odd : clk_even;
	
	//
	// Duty
	//
	reg [7:0] cnt_duty; // Used in duty generate
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    cnt_duty <= #`DEL 8'd0;
	  end
	  else if( ( duty_num == (division[7:0]>>1) ) || cnt_duty_flag || ~cnt_div_duty ) begin
	    // If duty is half of division[7:0] that means duty is 50%,
	    // use clk_div as clk_out
	    // If cnt_duty_flag is 1, then count begin from 0
	    cnt_duty <= #`DEL 8'd0;
	  end
	  else if( cnt_duty == division[7:0] )begin
	    cnt_duty <= #`DEL 8'd0;
	  end
	  else begin
	    cnt_duty <= #`DEL cnt_duty + 8'd1;
	  end
	end      
	
	//
	// Attention: duty_num is an input signal, which is equal to duty(%) * division
	reg clk_out_duty;
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    clk_out_duty <= #`DEL 1'b0;
	  end
	  else if( duty_num == (division[7:0]>>1) || cnt_duty_flag || ~cnt_div_duty ) begin
	    clk_out_duty <= #`DEL 1'b0;
	  end
	  else if( cnt_duty < duty_num )begin
	    clk_out_duty <= #`DEL 1'b1;
	  end
	  else begin
	    clk_out_duty <= #`DEL 1'b0;
	  end
	end      
	
	// While duty_num is half of division which means duty is 50%, clk_out is generated by the first method that is more accurate than the second method
	// While duty is not 50%,clk_out is generated by the 2nd way which duty is variable
	assign clk_out = ( duty_num == (division[7:0]>>1) || duty_num == 0 ) ? clk_out_div : clk_out_duty;
	
	//
	// Detect the change of duty_num and division
	//
	reg [7:0]  duty_num_temp;
	reg [7:0]  division_temp;
	reg        duty_num_flag;
	reg        division_flag;
	reg        cnt_duty_flag;
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    duty_num_temp <= #`DEL 8'd0;
	  end
	  else begin
	    duty_num_temp <= #`DEL duty_num;
	  end
	end      
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    division_temp <= #`DEL 8'd0;
	  end
	  else begin
	    division_temp <= #`DEL division;
	  end
	end 
	
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    duty_num_flag <= #`DEL 1'd0;
	    division_flag <= #`DEL 1'd0;
	  end
	  else if( duty_num_temp != duty_num )begin
	    duty_num_flag <= #`DEL 1'd1;
	  end
	  else if( division_temp != division )begin
	    division_flag <= #`DEL 1'd1;
	  end
	  else begin 
	    duty_num_flag <= #`DEL 1'd0;
	    division_flag <= #`DEL 1'd0;
	  end
	end      
	
	//
	// Generate the start counting signal of cnt_duty. If cnt_duty_flag is 1, which means division or duty_num has changed, then cnt_duty start count from 0 again
	always @( posedge clk or negedge rst_n ) begin
	  if( ~rst_n ) begin
	    cnt_duty_flag <= #`DEL 1'd0;
	  end
	  else if( duty_num_flag || division_flag )begin
	    cnt_duty_flag <= #`DEL 1'd1;
	  end
	  else begin
	    cnt_duty_flag <= #`DEL 1'd0;
	  end
	end 
	
	
endmodule    //division_duty

